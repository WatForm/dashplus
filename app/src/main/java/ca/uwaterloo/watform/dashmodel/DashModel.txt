
	public void resolveVarTable() {

		for (String vfqn: vt.keySet()) {
			String sfqn = DashFQN.chopPrefixFromFQN(vfqn);
			setVarType(
				vfqn,
					new ResolveDashExpr("var", false, false, true, sfqn).
						visitThis(getVarType(vfqn))
			);
		}
		// buffer types don't need resolving because just buf[element] 
	}
	public List<String> getNamesOfState(String sfqn) {
		List<String> x = getVarsOfState(sfqn);
		x.addAll(getBuffersOfState(sfqn));
		return x;		
	}
	// across both vartable and buffertable
	public List<String> getAllNames() {
		// vars plus buffers
		List<String> x = getAllVarNames();
		x.addAll(getAllBufferNames());
		return x;
	}

	/*
	 * check for errors and put all the trans that are at this level
	 * in the trans tt
	 * must be done after resolveAllState
	 * this fcn does not modify anything in this object
	 */
	public void resolveTrans(StateTable st, EventTable et, VarTable vt, PredTable pt) {

		//System.out.println(st);
		//System.out.println(toString());
		//System.out.println("Resolving trans tt");
		if (getAllNames().isEmpty()) DashErrors.noTrans();
		for (String tfqn: tt.keySet()) {
			//String tfqn = DashFQN.fqn(sfqn,t.name);
			String sfqn = DashFQN.chopPrefixFromFQN(tfqn);
			
			// determining the src state
			List<Expr> fList =
				tt.get(tfqn).fromList.stream()
				.map(p -> (p.getSrc()))
				.collect(Collectors.toList());

			if (fList.size() > 1) DashErrors.tooMany("from", tfqn);
			else if (fList.isEmpty()) 
				// can be a loop on root
				tt.get(tfqn)
					.setSrc(DashRef.createStateDashRef(sfqn, getParams(tfqn)));
			else 
				tt.get(tfqn)
					.setSrc((DashRef) new ResolveExpr(st, et, vt, pt, "state", false, false, true, sfqn).visitThis(fList.get(0)));
	
			// determining the dest state
			List<Expr> gList =
				tt.get(tfqn).gotoList.stream()
				.map(p -> (p.getDest()))
				.collect(Collectors.toList());

			if (gList.size() > 1) DashErrors.tooMany("goto", tfqn);
			else if (gList.isEmpty()) 
				// can be a loop on root
				tt.get(tfqn)
					.setDest(DashRef.createStateDashRef(sfqn, getParams(tfqn)));
			else 
				tt.get(tfqn)
					.setDest((DashRef) new ResolveExpr(st, et, vt, pt, "state", false, true, true, sfqn).visitThis(gList.get(0)));

			// determining the on (event)
			List<Expr> onExpList =
				tt.get(tfqn).onList.stream()
				.map(p -> (p.getExp()))
				.collect(Collectors.toList());
			if (onExpList.size() > 1) DashErrors.tooMany("on", tfqn);
			else if (!onExpList.isEmpty()) {
				tt.get(tfqn)
					.setOn((DashRef) new ResolveExpr(st, et, vt, pt, "event", false, false, true, sfqn).visitThis(onExpList.get(0)));
			}

			// determining the send
			List<Expr> sendExpList =
				tt.get(tfqn).sendList.stream()
				.map(p -> (p.getExp()))
				.collect(Collectors.toList());
			if (sendExpList.size() > 1) DashErrors.tooMany("send", tfqn);
			else if (!sendExpList.isEmpty()) {
				DashRef x = (DashRef) new ResolveExpr(st, et, vt, pt, "event", false, true, true, sfqn).visitThis(sendExpList.get(0));
				if (et.isEnvironmentalEvent(x.getName()))
					DashErrors.cantSendAnEnvEvent(sendExpList.get(0).pos(),sendExpList.get(0).toString());
				else
					tt.get(tfqn)
					.	setSend((DashRef) new ResolveExpr(st, et, vt, pt, "event", false, true, true, sfqn).visitThis(sendExpList.get(0)));
			}

			// determining the when (expr)
			List<Expr> whenExpList =
				tt.get(tfqn).whenList.stream()
				.map(p -> (p.getWhen()))
				.collect(Collectors.toList());
			if (whenExpList.size() > 1) DashErrors.tooMany("when", tfqn);
			else if (!whenExpList.isEmpty()) {
				tt.get(tfqn)
					.setWhen(new ResolveExpr(st, et, vt, pt, "var", false, false, true, sfqn). visitThis(whenExpList.get(0)));
			}

			// determining the do
			List<Expr> doExpList =
				tt.get(tfqn).doList.stream()
				.map(p -> (p.getDo()))
				.collect(Collectors.toList());
			if (doExpList.size() > 1) DashErrors.tooMany("on", tfqn);
			else if (!doExpList.isEmpty()) {
				// already resolved src/dest
				Expr action = doExpList.get(0);
				if (st.hasEnteredAction(getDest(tfqn).getName()))
					action = ExprHelper.createAnd(action,ExprHelper.createAndList(st.getEnteredAction(getDest(tfqn).getName())));
				if (st.hasExitedAction(getSrc(tfqn).getName()))
					action = ExprHelper.createAnd(action,ExprHelper.createAndList(st.getExitedAction(getSrc(tfqn).getName())));
				tt.get(tfqn)
					.setDo(new ResolveExpr(st, et, vt, pt, "var", true, true, true, sfqn).visitThis(action));
			}

		}

		// these are conservative measures of potential problems in the model

		// we check that every internal event is generated by some transitions
		// if not, may end up with some untriggerable transitions
		// there is no resolveEvents so this can be done here

		// we could limit this to int events that trigger something 
		// but it seems wrong to put in an unused internal event so we will flag it also

		List<String> intEventsGenerated = getAllNames().stream()
			.filter(i -> getSend(i)!=null)
			.map(i -> getSend(i).getName())
			.collect(Collectors.toList());
		List<String> intEventsNotGenerated = 
			et.getAllInternalEvents().stream()
			.filter(i -> !(intEventsGenerated.contains(i)))
			.collect(Collectors.toList());
		if (!intEventsNotGenerated.isEmpty())
			DashErrors.intEventsNotGenerated(intEventsNotGenerated);

		// we check that every external event is the trigger of some transition
		List<String> eventsThatTriggerTrans = getAllNames().stream()
			.filter(i -> getOn(i)!=null)
			.map(i -> getOn(i).getName())
			.collect(Collectors.toList());
		List<String> envEventsNotUsed = 
			et.getAllEnvironmentalEvents().stream()
			.filter(i -> !(eventsThatTriggerTrans.contains(i)))
			.collect(Collectors.toList());
		if (!envEventsNotUsed.isEmpty())
			DashErrors.envEventsNotUsed(envEventsNotUsed);

		// we check that every state is either a default state 
		// or the destination of some transition
		// or an AND state
		// this is VERY conservative
		List<String> transDest = getAllNames().stream()
			.filter(i -> getDest(i)!=null)
			.map(i -> getDest(i).getName())
			.collect(Collectors.toList());
		List<String> statesNotEntered = st.getAllNames().stream()
			.filter(i -> !(st.isDefault(i) || st.isAnd(i) || st.isRoot(i) || transDest.contains(i)))
			.collect(Collectors.toList());
		if (!statesNotEntered.isEmpty())
			DashErrors.statesNotEntered(statesNotEntered);
		isResolved = true;
	}

	public void resolveState(String root, EventTable et, VarTable vt, PredTable pt) {
		// resolve inits and invariants
		for (String sfqn: st.keySet()) {
			inits.addAll( 
				st.get(sfqn).origInits.stream()
					.map(i -> new ResolveDashExpr(this, et, vt, pt, "var", false, false, true, sfqn).visitThis(i.getExp()))
					.collect(Collectors.toList()));
			invs.addAll(
				st.get(sfqn).origInvariants.stream()
					.map(i -> new ResolveDashExpr(this, et, vt, pt, "var", false, false, true, sfqn).visitThis(i.getExp()))
					.collect(Collectors.toList()));
			// nothing to do for entered and exited
			// because they are resolved in context
		}
		isResolved = true;
	}
