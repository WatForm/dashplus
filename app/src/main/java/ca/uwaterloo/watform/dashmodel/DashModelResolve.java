/*
 * Resolve
 *
 * The purpose of this phase is to resolve all uses of
 * variables/events/states to full DashRefs.
 *
 */

package ca.uwaterloo.watform.dashmodel;

import static ca.uwaterloo.watform.utils.GeneralUtil.*;

import ca.uwaterloo.watform.dashast.dashref.*;
import ca.uwaterloo.watform.utils.*;
import java.util.List;

public class DashModelResolve extends DashModelInitialize {

    private ExprRefResolver er = new ExprRefResolver(st, tt, et, vt, bt, pt);

    public void resolve() {
        resolveStateTable();
        resolveTransTable();
        resolveVarTable();
        // buffer table does not need resolving because just buf[element] - no expression in
        // eventDecls
        // NADTODO: pred table  does not need resolving?
        // event table does not need resolving - no expression in eventDecls
        extraChecks();
    }

    private void resolveStateTable() {
        // resolve inits and invariants
        for (String sfqn : st.keySet()) {
            st.initsR.addAll(mapBy(st.get(sfqn).initsP, i -> er.resolveVar(i.exp, sfqn)));
            st.invsR.addAll(mapBy(st.get(sfqn).invsP, i -> er.resolveVar(i.exp, sfqn)));
        }
    }

    private void resolveVarTable() {
        // resolve types of vars
        for (String vfqn : vt.keySet()) {
            String sfqn = DashFQN.chopPrefixFromFQN(vfqn);
            vt.get(vfqn).typ = er.resolveVar(vt.get(vfqn).typ, sfqn);
        }
    }

    private void resolveTransTable() {
        if (tt.isEmpty()) Error.noTrans();
        for (String tfqn : tt.keySet()) {
            String sfqn = DashFQN.chopPrefixFromFQN(tfqn);
            TransElement trans = tt.get(tfqn);

            if (trans.fromP == null)
                // can be a loop on root
                trans.fromR = new StateDashRef(sfqn, trans.params);
            else trans.fromR = er.resolveState(trans.fromP.exp, sfqn);

            if (trans.gotoP == null)
                // can be a loop on root
                trans.gotoR = new StateDashRef(sfqn, trans.params);
            else trans.gotoR = er.resolveState(trans.gotoP.exp, sfqn);

            if (trans.onP == null) trans.onR = null;
            else trans.onR = er.resolveEvent(trans.onP.exp, sfqn);

            if (trans.sendP == null) trans.sendR = null;
            else {
                DashRef x = er.resolveEventPrimesOkInPrmExprs(trans.sendP.exp, sfqn);
                if (et.isEnvironmentalEvent(x.name))
                    Error.cantSendAnEnvEvent(trans.sendP.pos, x.toString());
                else trans.sendR = x;
            }

            if (trans.whenP == null) trans.whenR = null;
            else trans.whenR = er.resolveVar(trans.whenP.exp, sfqn);

            if (trans.doP == null) trans.doR = null;
            else trans.doR = er.resolveVarPrimesOkAnywhere(trans.doP.exp, sfqn);
        }
    }

    private void extraChecks() {
        // these are cross table checks on potential problems in the model

        // we check that every internal event is generated by some transition
        // if not, may end up with some untriggerable transitions
        // we could limit this to int events that trigger something
        // but it seems wrong to put in an unused internal event so we will flag it also
        List<String> intEventsNotGenerated =
                filterBy(et.getAllInternalEvents(), i -> !(tt.intEventsGenerated().contains(i)));
        if (!intEventsNotGenerated.isEmpty()) Error.intEventsNotGenerated(intEventsNotGenerated);

        // we check that every external event is the trigger of some transition
        List<String> envEventsNotUsed =
                filterBy(
                        et.getAllEnvironmentalEvents(),
                        i -> !(tt.eventsThatTriggerTrans().contains(i)));
        if (!envEventsNotUsed.isEmpty()) Error.envEventsNotUsed(envEventsNotUsed);

        // we check that every state is either a default state
        // or the destination of some transition
        // or an AND state
        // this is VERY conservative

        List<String> statesNotEntered =
                filterBy(
                        st.getAllNames(),
                        i ->
                                !(st.isDefault(i)
                                        || st.isAnd(i)
                                        || st.isRoot(i)
                                        || tt.allTransDestNames().contains(i)));
        if (!statesNotEntered.isEmpty()) Error.statesNotEntered(statesNotEntered);
    }

    private class Error {

        public static void noTrans() throws ErrorFatal {
            throw new ErrorUser("Dash Model does not contain any transitions");
        }

        public static void intEventsNotGenerated(List<String> intEventsNotGenerated)
                throws ErrorFatal {
            throw new ErrorUser(
                    "The following internal events are never generated: "
                            + strCommaList(intEventsNotGenerated));
        }

        public static void envEventsNotUsed(List<String> envEventsNotUsed) throws ErrorFatal {
            throw new ErrorUser(
                    "The following environmental events are never used: "
                            + strCommaList(envEventsNotUsed));
        }

        public static void statesNotEntered(List<String> statesNotEntered) throws ErrorFatal {
            throw new ErrorUser(
                    "The following states are not entered: " + strCommaList(statesNotEntered));
        }

        public static void cantSendAnEnvEvent(Pos pos, String expString) {
            throw new ErrorUser(pos + " can't send an environmental event: " + expString);
        }
    }
}
