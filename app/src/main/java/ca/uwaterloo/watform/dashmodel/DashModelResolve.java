/*
 * Resolve
 *
 * The purpose of this phase is to resolve all uses of
 * variables/events/states to full DashRefs.
 *
 */

package ca.uwaterloo.watform.dashmodel;

import static ca.uwaterloo.watform.utils.GeneralUtil.*;

import ca.uwaterloo.watform.dashast.DashFile;
import ca.uwaterloo.watform.dashast.dashref.*;
import ca.uwaterloo.watform.utils.*;
import java.util.Collections;
import java.util.List;

public class DashModelResolve extends DashModelInitialize {

    private ExprRefResolverVis er = new ExprRefResolverVis(st, tt, et, vt, bt, pt);

    public DashModelResolve(DashFile d) {
        super(d);
        this.resolve();
    }

    public void resolve() {
        resolveStateTable();
        System.out.println("resolved state");
        resolveTransTable();
        System.out.println("resolved trans");
        resolveVarTable();
        // buffer table does not need resolving because just buf[element] - no expression in
        // eventDecls
        // NADTODO: pred table  does not need resolving?
        // event table does not need resolving - no expression in eventDecls
        extraChecks();
    }

    private void resolveStateTable() {
        // resolve inits and invariants
        for (String sfqn : st.keySet()) {
            st.initsR.addAll(mapBy(st.get(sfqn).initsP, i -> er.resolveVar(i.exp, sfqn)));
            st.invsR.addAll(mapBy(st.get(sfqn).invsP, i -> er.resolveVar(i.exp, sfqn)));
        }
    }

    private void resolveVarTable() {
        // resolve types of vars
        for (String vfqn : vt.keySet()) {
            String sfqn = DashFQN.chopPrefixFromFQN(vfqn);
            vt.get(vfqn).typ = er.resolveVar(vt.get(vfqn).typ, sfqn);
        }
    }

    private void resolveTransTable() {
        if (tt.isEmpty()) Error.noTrans();
        for (String tfqn : tt.keySet()) {
            String sfqn = DashFQN.chopPrefixFromFQN(tfqn);
            TransElement trans = tt.get(tfqn);

            if (trans.fromP == null)
                // can be a loop on root
                trans.fromR = new StateDashRef(sfqn, trans.params);
            else trans.fromR = er.resolveState(trans.fromP.exp, sfqn);

            if (trans.gotoP == null)
                // can be a loop on root
                trans.gotoR = new StateDashRef(sfqn, trans.params);
            else trans.gotoR = er.resolveState(trans.gotoP.exp, sfqn);

            if (trans.onP == null) trans.onR = null;
            else trans.onR = er.resolveEvent(trans.onP.exp, sfqn);

            if (trans.sendP == null) trans.sendR = null;
            else {
                DashRef x = er.resolveEventPrimesOkInPrmExprs(trans.sendP.exp, sfqn);
                if (et.isEnvironmentalEvent(x.name))
                    Error.cantSendAnEnvEvent(trans.sendP.pos, x.toString());
                else trans.sendR = x;
            }

            if (trans.whenP == null) trans.whenR = null;
            else trans.whenR = er.resolveVar(trans.whenP.exp, sfqn);

            if (trans.doP == null) trans.doR = null;
            else trans.doR = er.resolveVarPrimesOkAnywhere(trans.doP.exp, sfqn);
        }
    }

    private void extraChecks() {
        // these are cross table checks on potential problems in the model

        // we check that every internal event is generated by some transition
        // if not, may end up with some untriggerable transitions
        // we could limit this to int events that trigger something
        // but it seems wrong to put in an unused internal event so we will flag it also
        List<String> intEventsNotGenerated =
                filterBy(et.getAllInternalEvents(), i -> !(tt.intEventsGenerated().contains(i)));
        if (!intEventsNotGenerated.isEmpty()) Error.intEventsNotGenerated(intEventsNotGenerated);

        // we check that every external event is the trigger of some transition
        List<String> envEventsNotUsed =
                filterBy(
                        et.getAllEnvironmentalEvents(),
                        i -> !(tt.eventsThatTriggerTrans().contains(i)));
        if (!envEventsNotUsed.isEmpty()) Error.envEventsNotUsed(envEventsNotUsed);

        // we check that every state is either a default state
        // or the destination of some transition
        // or an AND state
        // this is VERY conservative

        List<String> statesNotEntered =
                filterBy(
                        st.keySet(),
                        i ->
                                !(st.isDefault(i)
                                        || st.isAnd(i)
                                        || st.isRoot(i)
                                        || tt.allTransDestNames().contains(i)));
        if (!statesNotEntered.isEmpty()) Error.statesNotEntered(statesNotEntered);

        /*
            2024-02-21 NAD
            Do not allow any overlaps between namespaces: state, trans, event, var, buffers
            because in Electrum items from multiple of these categories can end up in the same
            Alloy namespace such as:

            one sig X extends Transitions {}
            var sig X in Typ {}

            If we tried to prefix names with trans_ or state_, FQNs would get VERY long
            Also, we want to be consistent with names across all methods (traces, tcmc, Electrum)
        */

        disj(vt.keySet(), pt.keySet());
        disj(vt.keySet(), st.keySet());
        disj(vt.keySet(), tt.keySet());
        disj(vt.keySet(), et.keySet());
        disj(vt.keySet(), bt.keySet());

        disj(tt.keySet(), st.keySet());
        disj(tt.keySet(), et.keySet());
        disj(tt.keySet(), bt.keySet());

        disj(st.keySet(), et.keySet());
        disj(st.keySet(), bt.keySet());

        disj(et.keySet(), bt.keySet());

        maxDepthParams = st.getMaxDepthParams();

        transAtThisParamDepth = tt.transAtThisParamDepth(maxDepthParams);
    }

    private void disj(List<String> alist, List<String> blist) {
        if (!Collections.disjoint(alist, blist)) {
            List<String> x = alist;
            x.retainAll(blist);
            Error.nameOverlap(x);
        }
    }

    private class Error {

        public static void noTrans() throws Reporter.ErrorUser {
            throw new Reporter.ErrorUser("Dash Model does not contain any transitions");
        }

        public static void intEventsNotGenerated(List<String> intEventsNotGenerated)
                throws Reporter.ErrorUser {
            throw new Reporter.ErrorUser(
                    "The following internal events are never generated: "
                            + strCommaList(intEventsNotGenerated));
        }

        public static void envEventsNotUsed(List<String> envEventsNotUsed)
                throws Reporter.ErrorUser {
            throw new Reporter.ErrorUser(
                    "The following environmental events are never used: "
                            + strCommaList(envEventsNotUsed));
        }

        public static void statesNotEntered(List<String> statesNotEntered)
                throws Reporter.ErrorUser {
            throw new Reporter.ErrorUser(
                    "The following states are not entered: " + strCommaList(statesNotEntered));
        }

        public static void cantSendAnEnvEvent(Pos pos, String expString) {
            throw new Reporter.ErrorUser(pos + " can't send an environmental event: " + expString);
        }

        public static void nameOverlap(List<String> s) {
            throw new Reporter.ErrorUser("Same name used for multiple purposes: " + s);
        }
    }
}
