/*
 * Resolve
 *
 * The purpose of this phase is to resolve all USES of
 * variables/events/states to full DashRefs.
 *
 * We have to walk over all the trans in the state table,
 * resolve the entries in the transition and create the transTable.
 *
 * We also create the invsR (resolved invariants) and
 * resolved inits).
 *
 */

package ca.uwaterloo.watform.dashmodel;

import static ca.uwaterloo.watform.utils.GeneralUtil.*;

import ca.uwaterloo.watform.alloyast.expr.AlloyExpr;
import ca.uwaterloo.watform.dashast.*;
import ca.uwaterloo.watform.dashast.dashref.*;
import ca.uwaterloo.watform.utils.*;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class ResolveDM extends ResolverVisDM {

    public ResolveDM(DashFile d) {
        super(d);
        myprint("==== BEFORE RESOLUTION ====");
        this.debug();
        resolveVarTable();
        stateRecurseForTransInitsInvs(d.stateRoot, null);
        // buffer table does not need resolving
        // because buf[element] has no expression in it

        // event table does not need resolving
        // because it has no expressions in it

        // TODO: pred table needs resolving????
        extraChecks();
        myprint("==== AFTER RESOLUTION ====");
        this.debug();
    }

    public ResolveDM() {
        super();
        // everything added must be resolved
    }

    private void resolveVarTable() {
        for (String vfqn : allVarNames()) {
            String sfqn = DashFQN.chopPrefixFromFQN(vfqn);
            // setter
            setVarTyp(vfqn, resolveVar(varTyp(vfqn), sfqn));
        }
    }

    private void stateRecurseForTransInitsInvs(DashState s, String parentFQN) {
        // Add the transitions,inits,invs to the transTable
        // after resolving the parts
        // walk over the DashAST again

        // have to calculate the sfqn again
        // but we can look up the params for the sfqn
        // parentFQN could be empty string
        String sfqn = DashFQN.fqn(parentFQN, s.name);
        // the params are also deduced in the resolvers
        // so they are not passed as an additional arg to
        // the resolvers
        List<DashParam> sparams = new ArrayList<>(stateParams(sfqn));

        this.initsR.addAll(mapBy(s.inits(), i -> resolveVar(i.exp, sfqn)));
        this.invsR.addAll(mapBy(s.invs(), i -> resolveVar(i.exp, sfqn)));

        for (DashTrans t : s.trans()) {

            String tfqn = DashFQN.fqn(sfqn, t.name);
            DashRef fromR =
                    (t.fromP == null)
                            // loop on root
                            ? new StateDashRef(sfqn, sparams)
                            : resolveState(t.fromP.exp, sfqn);

            DashRef gotoR =
                    (t.gotoP == null)
                            // loop on root
                            ? new StateDashRef(sfqn, sparams)
                            : resolveState(t.gotoP.exp, sfqn);

            DashRef onR = (t.onP == null) ? null : resolveEvent(t.onP.exp, sfqn);

            DashRef sendR = null;
            if (t.sendP == null) sendR = null;
            else {
                DashRef x = resolveEventPrimesOkInPrmExprs(t.sendP.exp, sfqn);
                if (isEnvEvent(x.name)) Error.cantSendAnEnvEvent(t.sendP.pos, x.toString());
                else sendR = x;
            }

            AlloyExpr whenR = (t.whenP == null) ? null : resolveVar(t.whenP.exp, sfqn);

            AlloyExpr doR = (t.doP == null) ? null : resolveVarPrimesOkAnywhere(t.doP.exp, sfqn);

            this.addTrans(t.pos, tfqn, sparams, fromR, onR, whenR, gotoR, sendR, doR);
        }
        for (DashState c : s.substates()) {
            stateRecurseForTransInitsInvs(c, sfqn);
        }
    }

    private void extraChecks() {
        // these are cross table checks on potential
        // problems in the model

        if (!hasTrans()) Error.noTrans();

        // we check that every internal event is generated by some transition
        // if not, may end up with some untriggerable transitions
        // we could limit this to int events that trigger something
        // but it seems wrong to put in an unused internal event so we will flag it also
        List<String> intEventsNotGenerated =
                filterBy(allIntEvents(), i -> !(intEventsGenerated().contains(i)));
        if (!intEventsNotGenerated.isEmpty()) Error.intEventsNotGenerated(intEventsNotGenerated);

        // we check that every external event is the trigger of some transition
        List<String> envEventsNotUsed =
                filterBy(allEnvEvents(), i -> !(eventsThatTriggerTrans().contains(i)));
        if (!envEventsNotUsed.isEmpty()) Error.envEventsNotUsed(envEventsNotUsed);

        // we check that every state is either a default state
        // or the destination of some transition
        // or an AND state
        // this is VERY conservative estimate of what states are not entered
        // some states might not be entered and might not make it on this list

        List<String> statesNotEntered =
                filterBy(
                        allStateNames(),
                        i ->
                                !(isDefault(i)
                                        || isAnd(i)
                                        || isRoot(i)
                                        || transDestNames().contains(i)));
        if (!statesNotEntered.isEmpty()) Error.statesNotEntered(statesNotEntered);

        /*
            2024-02-21 NAD
            Do not allow any overlaps between namespaces:
             state, trans, event, var, buffers
            because in Electrum items from multiple of
            these categories can end up in the same
            Alloy namespace such as:

            one sig X extends Transitions {}
            var sig X in Typ {}

            If we tried to prefix names with trans_ or state_, FQNs would get VERY long
            Also, we want to be consistent with names across all methods (traces, tcmc, Electrum)
        */

        disj(allVarNames(), allPredNames());
        disj(allVarNames(), allStateNames());
        disj(allVarNames(), allTransNames());
        disj(allVarNames(), allEventNames());
        disj(allVarNames(), allBufferNames());

        disj(allTransNames(), allStateNames());
        disj(allTransNames(), allEventNames());
        disj(allTransNames(), allBufferNames());

        disj(allStateNames(), allEventNames());
        disj(allStateNames(), allBufferNames());

        disj(allEventNames(), allBufferNames());
    }

    private void disj(List<String> alist, List<String> blist) {
        if (!Collections.disjoint(alist, blist)) {
            List<String> x = alist;
            x.retainAll(blist);
            Error.nameOverlap(x);
        }
    }


    public void debug() {
        System.out.println(stToString());
        System.out.println(ttToString());
        System.out.println(etToString());
        System.out.println(vtToString());
        System.out.println(btToString());
        System.out.println(ptToString());
    }

    public void debug(String tfqn) {
        if (tfqn != null) {
            System.out.println("src " + fromR(tfqn));
            System.out.println("dest " + gotoR(tfqn));
            System.out.println("pre " + whenR(tfqn));
            System.out.println("post " + doR(tfqn));
            System.out.println("getScope " + scope(tfqn));
            System.out.println("getClosestParamAnces: " + closestParamAnces(fromR(tfqn).name));
            // System.out.println("getAllNonParamDesc: "
            // +getAllNonParamDesc(getClosestConcAnces(getTransSrc(tfqn).getName())));
            System.out.println("getRegion:" + "Root/S1/S2: " + region(fromR(tfqn).name));
            System.out.println("exited: " + exited(tfqn));
            System.out.println("entered" + leafStatesEntered(gotoR(tfqn)));
            System.out.println("enteredInScope" + entered(tfqn));
            System.out.println("allPrefixDashRefs of scope: " + prefixDashRefs(scope(tfqn)));
            System.out.println("scopesUsed: " + scopesUsed(tfqn));
            System.out.println("nonOrthogonalScopes: " + nonOrthogonalScopesOf(tfqn));
        }
    }

    private class Error {

        public static void noTrans() throws Reporter.ErrorUser {
            throw new Reporter.ErrorUser("Dash Model does not contain any transitions");
        }

        public static void intEventsNotGenerated(List<String> intEventsNotGenerated)
                throws Reporter.ErrorUser {
            throw new Reporter.ErrorUser(
                    "The following internal events are never generated: "
                            + strCommaList(intEventsNotGenerated));
        }

        public static void envEventsNotUsed(List<String> envEventsNotUsed)
                throws Reporter.ErrorUser {
            throw new Reporter.ErrorUser(
                    "The following environmental events are never used: "
                            + strCommaList(envEventsNotUsed));
        }

        public static void statesNotEntered(List<String> statesNotEntered)
                throws Reporter.ErrorUser {
            throw new Reporter.ErrorUser(
                    "The following states are not entered: " + strCommaList(statesNotEntered));
        }

        public static void cantSendAnEnvEvent(Pos pos, String expString) {
            throw new Reporter.ErrorUser(pos + " can't send an environmental event: " + expString);
        }

        public static void nameOverlap(List<String> s) {
            throw new Reporter.ErrorUser("Same name used for multiple purposes: " + s);
        }
    }
}
